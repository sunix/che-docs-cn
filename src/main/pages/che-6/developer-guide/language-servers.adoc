---
title: "语言支持"
keywords: framework, language servers, code assistant, language support, code completion, error marking
tags: [extensions, assembly, dev-docs]
sidebar: che_6_docs
permalink: che-6/language-servers.html
redirect_from: language-servers.html
folder: che-6/developer-guide
---


[id="overview"]
== 概览

语言服务器协议在工具（客户端）和语言智能提供者（服务器）之间用于集成诸如自动完成、goto定义、查找引用等特性。  


你能从 https://github.com/Microsoft/language-server-protocol[LSP GitHub page] 了解更多关于语言服务器协议规格的内容。 
 

目前 Eclipse Che 实现了 https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md[3.x protocol version]。

注意，Eclipse Che还实现了VSCode中使用的片段语法。LSP规范中没有对它形成版本，但是在 https://github.com/Microsoft/vscode/blob/0ebd01213a65231f0af8187acaf264243629e4dc/src/vs/editor/contrib/snippet/browser/snippet.md[这里] 描述了所支持的语法。

[id="adding-support-for-new-languages"]
== 增加对新语言的支持

有两种途径用于增加一种新的语言服务器：  

* 通过安装程序(installer)和启动程序(launcher): 这种方式语言服务器运行在对应安装程序(installer)已经可用的机器上。
* 在工作空间配置中增加link:#ls-sidecars[language server as a sidecar] - 多服务器清单 + 带有需要属性的服务器

[id="general-concept"]
== 通用概念

语言服务器集成分为两个步骤：安装后再单独触发启动。当代理启动时，不会启动语言服务器。相反，它们是在第二步中启动的，可以在任何时候触发。这样做是为了减少资源消耗和减少工作空间启动时间。

1.  语言服务器代理在工作空间启动时被启动 - 其作用是安装所有的依赖项和准备将用于启动语言服务器的 `bash` 启动文件。
2.  https://github.com/eclipse/che/blob/master/wsagent/che-core-api-languageserver/src/main/java/org/eclipse/che/api/languageserver/launcher/LanguageServerLauncher.java[启动程序(lancher)]被触发并启动语言服务器。我们建议在用户开始操作与语言服务器相关的文件类型时再触发启动。一旦完成启动，语言服务器与特定的文件类型(详见后文)一起被注册。

[id="adding-a-language-server-installer"]
== 增加语言服务器安装程序(Installer)

按照有关文档完成 link:custom-installers.html[增加新的安装程序]

你能从已有的语言服务器代理的示例中进行学习：

* https://github.com/eclipse/che/tree/master/agents/ls-json[JSON]
* https://github.com/eclipse/che/tree/master/agents/ls-php[PHP]
* https://github.com/eclipse/che/tree/master/agents/ls-python[Python]
* https://github.com/eclipse/che/tree/master/agents/ls-csharp[C#]
* https://github.com/eclipse/che/tree/master/agents/ls-typescript[TypeScript]

[id="adding-a-language-server-config"]
== 增加一个语言服务器的配置

为了启动/初始化某预定的语言的语言服务器，你需要实现 https://github.com/eclipse/che/blob/master/wsagent/che-core-api-languageserver/src/main/java/org/eclipse/che/api/languageserver/LanguageServerConfig.java[LanguageServerConfig interface] ,它完整定义了启动一个 `local` 语言服务器所需要完成的事情。

这是一个典型的LanguageServerConfig，它看上去应该像 https://github.com/eclipse/che/blob/master/plugins/plugin-clangd/che-plugin-clangd-lang-server/src/main/java/org/eclipse/plugin/clangd/languageserver/ClangDLanguageServerConfig.java[Clangd] 这样。

需注意的事情是：

* *REGEX* defines regexp for desired files. It can be a path, all fines with certain extension or particular file names etc.
* *launchScript* is usually created by an installer script and contains command(s) to launch a language server in a stdio mode
* *LANGUAGE_ID* is defined in a guice module. See: https://github.com/eclipse/che/blob/master/plugins/plugin-clangd/che-plugin-clangd-lang-server/src/main/java/org/eclipse/plugin/clangd/inject/ClangModule.java[ClangdModule]
* add binding in https://github.com/eclipse/che/blob/master/plugins/plugin-clangd/che-plugin-clangd-lang-server/src/main/java/org/eclipse/plugin/clangd/inject/ClangModule.java#L37[guice module]

Installers are packaged into wsmaster, so you will need to add required dependencies there. LanguageServerConfigs are usually part of plugins packages with a workspace agent.

[id="ls-sidecars"]
== LS-Sidecars

While the above approach works well for custom assemblies, i.e. you actually need to rebuild Che with a custom plugin that registers a new installer and a language server launcher, there is a mechanism to launch Language Servers in parallel containers/sidecars. This is what you need to do to add a new language server to your workspace as a sidecar.

* Build a Docker image in which language server is started in `ENTRYPOINT` or `CMD`. Note that some language servers support `tcp` arguments in their start syntax. Make sure that the language server acts like a server, rather than attempts to bind to a socket. The best way to check it is to run the image: `docker run -ti ${image}`. If the container starts, everything is fine, and if it exits immediately, you need to fix it.

We recommend running language servers in `stdio` mode and use sockat as a proxy. Here’s an example of a Dockerfile that builds an image with TyperScript language server:

----
# inherit an image with node.js and npm - runtime requirements for TypeScript LS
FROM eclipse/node

# install socat
RUN sudo apt-get install socat -y && \
    sudo npm install -g typescript@2.5.3 typescript-language-server@0.1.4

# run socat that listens on port 4417 with exec command that starts LS
CMD socat TCP4-LISTEN:4417,reuseaddr,fork EXEC:"typescript-language-server --stdio"
----

* Create a stack with a link:creating-starting-workspaces.html[custom recipe]: Create Workspace > Add Stack:

[source,yaml]
----
services:
 typescript-ls-machine:
  image: ls/image
  mem_limit: 1073741824
 dev-machine:
  image: eclipse/ubuntu_jdk8
  mem_limit: 2147483648
  depends_on:
   - typescript-ls-machine
----

* In User Dashboard, go to *Workspaces > Your Workspace > Config*, and add a server for typescript-ls-machine in `servers:[]`

[source,json]
----
"servers": {
  "ls": {
    "attributes": {
      "id": "go-ls",
      "internal": "true",
      "type": "ls",
      "languageRegexes": "[ {\"languageId\":\"golang\", \"regex\":\".*\\\\.go$\"}]",
    },
    "protocol": "tcp",
    "port": "4417"
  }
}
----

* *ls* - server name - can be any string
* *attributes.id* - can be any unique identifier
* *attributes.internal* - `true`. Mandatory! Used to get an internal link to server
* *attributes.type* - `ls`. Mandatory. Used by the IDE client to identify a server as a language server
* *languageRegexes.languageId* - language identifier, either one of those supported in [LSP specification] (https://microsoft.github.io/language-server-protocol/specification#textdocumentitem) or own.
* *languageRegexes.regex* - regexp expression to match either extension or file name + extension, or whatever match you need (for example, path, say, initialize language server only for config/config.xml files). Pay attention to regexp syntax since errors are not validated by server, and bad regexp will result in the client ignoring your files.
* In User Dashboard, go to Workspaces > Your Workspace > Volumes, add a volume for *each machine*. The two volumes have to share the same name (for example, `projects`) and path `/projects` so that they actually share one volume. This way a language server container has access to workspace project types.

image::extensibility/lang_servers/volumes_ls.png[]

* Start a workspace. Open a file with one of the extensions bound to a language ID. Che client will attempt to connect to language server over tcp socket. This data is retrieved from workspace runtime. Language server process should be available at the port declared in the server. You can either use Socat or launch a language server in tcp mode if it supports it. It is your Docker image’s responsibility to launch the language server. Adding `ENTRYPOINT` or `CMD` instruction should work well.

See: https://gist.githubusercontent.com/eivantsov/4e86b4d51cf23fbd8fd68410170f06e3/raw/e9c1edc600d0ff82e15d2d68d2ac5c6304a981b9/go-workspace.json[Sample configuration] of a workspace featuring 2 machines, one of which is a language server machine.
